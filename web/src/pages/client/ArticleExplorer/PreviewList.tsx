/*
 * @Author: yolo
 * @Date: 2025-09-18 14:47:22
 * @LastEditors: yolo
 * @LastEditTime: 2025-09-18 17:25:36
 * @FilePath: /Blog/web/src/pages/client/ArticleExplorer/PreviewList.tsx
 * @Description: 文章列表
 */

import { memo } from 'react';
import { Link } from 'react-router-dom';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeSlug from 'rehype-slug';
import rehypeAutolinkHeadings from 'rehype-autolink-headings';
import '@/assets/styles/markdown.scss';

interface Article {
  id: number;
  title: string;
  content: string;
}

const articles: Article[] = [
  {
    id: 1,
    title: 'React 学习笔记',
    content:
      "\n![](https://user-gold-cdn.xitu.io/2018/9/29/1662310b4cdab44f?w=1071&h=604&f=png&s=62218)\n\n### 什么是 webpack\n\nwebpack 可以看做是模块打包机：他做的事情是，分析你的项目结构，找到 `JavaScript` 模块以及其他的一些浏览器不能直接运行的扩展语言（`Scss`、`TypeScript` 等），将其打包为合适的格式以供浏览器使用\n\n构建就是把源代码转换成发布到线上可执行的 `JavaScript`、CSS、HTML 代码，包括以下内容：\n\n- **代码转换**：`TypeScript` 编译成 `JavaScript`、`SCSS` 编译成 CSS 等等\n- **文件优化**：压缩 `JavaScript`、CSS、HTML 代码，压缩合并图片等\n- **代码分割**：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载\n- **模块合并**：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件\n- **自动刷新**：监听本地源代码的变化，自动构建，刷新浏览器\n- **代码校验**：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过\n- **自动发布**：更新完代码后，自动构建出线上发布代码并传输给发布系统。\n\n构建其实是工程化、自动化思想在前端开发中的体现。把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。\n\n<!--more-->\n\n#### webpack 的基本概念\n\n- [入口(entry point)](https://www.webpackjs.com/concepts/entry-points/): 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始，webpack 会找出有哪些模块和 library 是入口起点（直接和间接）依赖的。\n\n  - 默认值是 `./src/index.js`，然而，可以通过在 webpack 配置中配置 entry 属性，来指定一个不同的入口起点（或者也可以指定多个入口起点）。\n\n- [出口 output](https://www.webpackjs.com/concepts/output/): 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，主输出文件默认为 `./dist/main.js`，其他生成文件的默认输出目录是 `./dist`\n\n- [loader](https://www.webpackjs.com/concepts/loaders/): 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。\n\n> 注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。\n\n- [插件 plugins](https://www.webpackjs.com/concepts/plugins/): loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。\n\n- [模式 mode](https://www.webpackjs.com/concepts/mode/): 通过选择 `development` 或 `production` 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化\n\n#### webpack 构建过程\n\n1. 从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。\n2. 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则。\n3. 对 Module 进行转换后，再解析出当前 Module 依赖的 Module。\n4. 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。\n5. 最后 Webpack 会把所有 Chunk 转换成文件输出。\n6. 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。\n\n### 开发环境和生产环境\n\n我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，一套供线上使用。\n\n- **development**: 用于开发的配置文件，用于定义 `webpack dev server` 和其他东西\n- **production**: 用于生产的配置文件，用于定义 `UglifyJSPlugin`，`sourcemaps` 等\n\n简单来说，开发时可能需要打印 debug 信息，包含 `sourcemap` 文件，而生产环境是用于线上的即代码都是压缩后，运行时不打印 debug 信息等。譬如 axios、antd 等我们的生产环境中需要使用到那么我们应该安装该依赖在生产环境中，而 `webpack-dev-server` 则是需要安装在开发环境中\n\n平时我们 `npm` 中安装的文件中有 -S -D, -D 表示我们的依赖是安装在开发环境的，而-S 的是安装依赖在生产环境中。\n\n本文就来带你搭建基本的前端开发环境，前端开发环境需要什么呢？\n\n- 构建发布需要的 HTML、CSS、JS、图片等资源\n- 使用 CSS 预处理器，这里使用 less\n- 配置 babel 转码器 => 使用 es6+\n- 处理和压缩图片\n- 配置热加载，HMR\n\n以上配置就可以满足前端开发中需要的基本配置。下面是本文打包后的效果图：\n\n![](https://user-gold-cdn.xitu.io/2018/9/30/16629c066f166b7a?w=1420&h=528&f=png&s=154990)\n\n### 搭建基本的开发环境\n\n### 安装\n\n```\nmkdir webpack-dev && cd webpack-dev\nnpm init -y\nnpm i webpack webpack-cli -D\n```\n\n### 添加 scripts\n\n生成了 package.json 文件，在文件中添加\n\n```json\n \"scripts\": {\n    \"build\": \"webpack --mode production\"\n  }\n```\n\n> --`mode` 模式 (必选，不然会有 `WARNING`)，是 `webpack4` 新增的参数选项，默认是 `production`\n\n- `--mode production` 生产环境\n  - 提供 `uglifyjs-webpack-plugin` 代码压缩\n  - 不需要定义 `new webpack.DefinePlugin({ \"process.env.NODE_ENV\": JSON.stringify(\"production\") })` 默认 `production`\n  - 默认开启 `NoEmitOnErrorsPlugin -> optimization.noEmitOnErrors`, 编译出错时跳过输出，以确保输出资源不包含错误\n  - 默认开启 `ModuleConcatenationPlugin` -> `optimization.concatenateModules`, `webpack3` 添加的作用域提升(`Scope Hoisting`)\n- `--mode development` 开发环境\n  - 使用 eval 构建 module, 提升增量构建速度\n  - 不需要定义 `new webpack.DefinePlugin({ \"process.env.NODE_ENV\": JSON.stringify(\"development\") })` 默认 `development`\n  - 默认开启 `NamedModulesPlugin -> optimization.namedModules` 使用模块热替换(HMR)时会显示模块的相对路径\n\n添加了 scripts 之后，新建`src/index.js`，然后执行`npm run build` ，你就会发现新增了一个 `dist` 目录，里边存放的是 webpack 构建好的 `main.js` 文件。\n\nps [npm scripts 使用指南](http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html)\n\n### 新建 webpack.config.js 文件\n\n要想对 webpack 中增加更多的配置信息，我们需要建立一个 webpack 的配置文件。在根目录下创建 `webpack.config.js` 后再执行 `webpack` 命令，webpack 就会使用这个配置文件的配置了\n\n配置中具备以下的基本信息：\n\n```js\nmodule.exports = {\n  entry: '', // 打包入口：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始\n  output: '', // 出口\n  resolve: {}, // 配置解析：配置别名、extensions 自动解析确定的扩展等等\n  devServer: {}, // 开发服务器：run dev/start 的配置，如端口、proxy等\n  module: {}, // 模块配置：配置loader（处理非 JavaScript 文件，比如 less、sass、jsx、图片等等）等\n  plugins: [] // 插件的配置：打包优化、资源管理和注入环境变量\n}\n```\n\n#### 配置打包入口和出口\n\n首先我们往 `webpack.config.js` 添加点配置信息\n\n```js\nconst path = require('path')\n\nmodule.exports = {\n  // 指定打包入口\n  entry: './src/index.js',\n\n  // 打包出口\n  output: {\n    path: path.resolve(__dirname, 'dist'), // 解析路径为 ./dist\n    filename: 'bundle.js'\n  }\n}\n```\n\n上面我们定义了打包入口 `./src/index.js`，打包出口为 `./dist`, 打包的文件夹名字为`bundle.js`，执行`npm run build`命令后，index.js 文件会被打包为 `bundle.js` 文件。此时随便建立一个 html 文件引用这个`bundle.js`就可以看到你在`index.js` 写的代码了。\n\n[path.resolve([...paths])](http://nodejs.cn/api/path.html#path_path_resolve_paths) 方法会把一个路径或路径片段的序列解析为一个绝对路径。\n\n### 使用 html-webpack-plugin 创建 html 文件\n\n更多情况下我们不希望打包一次，就新建一次 html 文件来引用打包后的文件，这样显得不智能或者说当你打包的文件名修改后，引用路径就会出错。\n\n这个时候我们就可以使用 [html-webpack-plugin](https://webpack.docschina.org/plugins/html-webpack-plugin/) 插件来将 HTML 引用路径和我们的构建结果关联起来。\n\n```\nnpm install html-webpack-plugin -D\n```\n\n创建文件`public/index.html` 修改 `webpack.config.js` 文件\n\n```js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  //...\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: './public/index.html' // 配置要被编译的html文件\n    })\n  ]\n}\n```\n\n重新执行 `npm run build`, dist 目录就会多个 `index.html` 并引入了 `bundle.js`.\n\n#### 压缩 html 文件\n\n修改 `webpack.config.js`\n\n```js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  //...\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: './public/index.html', // 配置要被编译的html文件\n      hash: true,\n      // 压缩 => production 模式使用\n      minify: {\n        removeAttributeQuotes: true, //删除双引号\n        collapseWhitespace: true //折叠 html 为一行\n      }\n    })\n  ]\n}\n```\n\n### 打包 css 文件\n\n我们希望使用 webpack 来进行构建 css 文件，，为此，需要在配置中引入 loader 来解析和处理 CSS 文件：\n\n```\nnpm install style-loader css-loader -D\n```\n\n新建 `src/assets/style/color.css`, 修改 `webpack.config.js` 文件：\n\n```js\nmodule.exports = {\n  //...\n  module: {\n    /**\n     * test: 匹配特定条件。一般是提供一个正则表达式或正则表达式的数组\n     * include: 匹配特定条件。一般是提供一个字符串或者字符串数组\n     * exclude: 排除特定条件\n     * and: 必须匹配数组中的所有条件\n     * or: 匹配数组中任何一个条件,\n     * nor: 必须排除这个条件\n     */\n    rules: [\n      {\n        test: /\\.css$/,\n        include: [path.resolve(__dirname, 'src')],\n        use: ['style-loader', 'css-loader']\n      }\n    ]\n  }\n  //...\n}\n```\n\n经由上述两个 loader 的处理后，CSS 代码会转变为 JS， 如果需要单独把 CSS 文件分离出来，我们需要使用 [mini-css-extract-plugin](https://github.com/webpack-contrib/mini-css-extract-plugin) 插件\n\n#### 抽取 css 到独立文件, 自动添加前缀\n\n```\nnpm i mini-css-extract-plugin postcss-loader autoprefixer -D\n```\n\n我们在写 css 时不免要考虑到浏览器兼容问题，如 `transform` 属性，需要添加浏览器前缀以适配其他浏览器。故使用到 `postcss-loader` 这个 loader， 下面则是相关的配置\n\n`webpack.config.js`\n\n```js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        include: [path.resolve(__dirname, 'src')],\n        use: [\n          MiniCssExtractPlugin.loader,\n          'css-loader',\n          {\n            loader: 'postcss-loader',\n            options: {\n              plugins: [require('autoprefixer')]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    //...\n    new MiniCssExtractPlugin({\n      filename: '[name].css',\n      chunkFilename: '[id].css'\n    })\n  ]\n}\n```\n\n#### 打包 less 文件\n\n开发中通常会用到一门预处理语言，这里以`less`为例，通过`less-loader`可以打包 less 为 css 文件\n\n```\nnpm install less less-loader -D\n```\n\n新建 `src/assets/style/index.less`, 并且在 `src/index.js` 中引入 `import './assets/style/index.less'`\n\n配置 `webpack.config.js`\n\n```js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\nmodule.exports = {\n  module: {\n    rules: [\n      // ...\n      {\n        test: /\\.less$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          'css-loader',\n          {\n            loader: 'postcss-loader',\n            options: {\n              plugins: [require('autoprefixer')] // 添加css中的浏览器前缀\n            }\n          },\n          'less-loader'\n        ]\n      }\n    ]\n  }\n  //...\n}\n```\n\n执打包命令后就可以发现 `index.less` 中写的样式会和`color.css`一样被打包进 `main.css`中。\n\n[webpack@v4 升级踩坑](https://segmentfault.com/a/1190000014396803?utm_source=tag-newest): 关于使用 `mini-css-extract-plugin` 的注意点。\n\n### 打包图片\n\n```\nnpm install file-loader url-loader -D\n```\n\n**file-loader:** 可以用于处理很多类型的文件，它的主要作用是直接输出文件，把构建后的文件路径返回。\n\n**url-loader:**\n如果图片较多，会发很多 http 请求，会降低页面性能。`url-loader` 会将引入的图片编码，生成 dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此 `url-loader` 提供了一个 limit 参数，小于 limit 字节的文件会被转为 DataURl，大于 limit 的还会使用 `file-loader` 进行 copy。\n\n- url-loader 可以看作是增强版的 file-loader。\n- url-loader 把图片编码成 base64 格式写进页面，从而减少服务器请求。\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      // ...\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              outputPath: 'images/', //输出到images文件夹\n              limit: 500 //是把小于500B的文件打成Base64的格式，写入JS\n            }\n          }\n        ]\n      }\n    ]\n  }\n  //...\n}\n```\n\n**url-loader 和 file-loader 是什么关系呢？**\n\n简单地说，`url-loader` 封装了 `file-loader`。`url-loader` 不依赖于 `file-loader`，即使用 `url-loader` 时，只需要安装 `url-loader` 即可，不需要安装 `file-loader`，因为 `url-loader` 内置了 `file-loader`。\n\n通过上面的介绍，我们可以看到，url-loader 工作分两种情况：\n\n- 文件大小小于 limit 参数，url-loader 将会把文件转为 DataURL；\n- 文件大小大于 limit，url-loader 会调用 file-loader 进行处理，参数也会直接传给 file-loader。因此我们只需要安装 url-loader 即可。\n\n有关 `url-loader` 和 `file-loader` 的解析：[webpack 之图片引入-增强的 file-loader：url-loader](https://blog.csdn.net/hdchangchang/article/details/80175782)\n\n### 配置 babel\n\n#### babel-loader\n\n`Babel` 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS 代码。\n\nBabel 7 的相关依赖包需要加上 `@babel` scope。一个主要变化是 presets 设置由原来的 `env` 换成了 `@babel/preset-env`, 可以配置 `targets`, `useBuiltIns` 等选项用于编译出兼容目标环境的代码。其中 `useBuiltIns` 如果设为 `\"usage\"`，Babel 会根据实际代码中使用的 ES6/ES7 代码，以及与你指定的 targets，按需引入对应的 `polyfill`，而无需在代码中直接引入 `import '@babel/polyfill'`，避免输出的包过大，同时又可以放心使用各种新语法特性。\n\n```\nnpm i babel-loader @babel/core @babel/preset-env -D\n```\n\n笔者这里配的版本号如下\n\n```json\n{\n  \"babel-loader\": \"^8.0.4\",\n  \"@babel/core\": \"^7.1.2\",\n  \"@babel/preset-env\": \"^7.1.0\"\n}\n```\n\n- [babel-loader](https://www.npmjs.com/package/babel-loader): 用 babel 转换 ES6 代码需要使用到 `babel-loader`\n- [@babel-preset-env](https://www.npmjs.com/package/@babel/preset-env)： 默认情况下是等于 ES2015 + ES2016 + ES2017，也就是说它对这三个版本的 ES 语法进行转化。\n- [@babel/core](https://www.npmjs.com/package/@babel/core)：babel 核心库\n\n根目录下新建 `.babelrc` 文件\n\n```json\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"modules\": false,\n        \"targets\": {\n          \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie <= 8\"]\n        },\n        \"useBuiltIns\": \"usage\"\n      }\n    ]\n  ]\n}\n```\n\n- presets 是一堆 plugins 的预设，起到方便的作用。\n- plugins 是编码转化工具，babel 会根据你配置的插件对代码进行相应的转化。\n\n修改 `webpack.config.js`\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      //...\n      {\n        test: /\\.m?js$/,\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: 'babel-loader'\n        }\n      }\n    ]\n  }\n}\n```\n\n#### babel/polyfill 和 transform-runtime\n\n> Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。\n\n- babel-polyfill: 如上述所说，对于新的 API，你可能需要引入 babel-polyfill 来进行兼容\n- 关键点\n\n  - babel-polyfill 是为了模拟一个完整的 ES2015+环境，旨在用于应用程序而不是库/工具。\n  - babel-polyfill 会污染全局作用域\n\nbabel-runtime 的作用：\n\n- **提取辅助函数**。ES6 转码时，babel 会需要一些辅助函数，例如 \\_extend。babel 默认会将这些辅助函数内联到每一个 js 文件里， babel 提供了 transform-runtime 来将这些辅助函数“搬”到一个单独的模块 babel-runtime 中，这样做能减小项目文件的大小。\n- **提供 polyfill**：不会污染全局作用域，但是不支持实例方法如 Array.includes\n\n`babel-runtime` 更像是分散的 polyfill 模块，需要在各自的模块里单独引入，借助 `transform-runtime` 插件来自动化处理这一切，也就是说你不要在文件开头 import 相关的 `polyfill`，你只需使用，`transform-runtime` 会帮你引入。\n\n对于开发应用来说，直接使用上述的按需 `polyfill` 方案是比较方便的，但如果是开发工具、库的话，这种方案未必适合（`babel-polyfill` 是通过向全局对象和内置对象的 `prototype` 上添加方法实现的，会造成全局变量污染）。Babel 提供了另外一种方案 `transform-runtime`，它在编译过程中只是将需要 `polyfill` 的代码引入了一个指向 `core-js` 中对应模块的链接(alias)。关于这两个方案的具体差异和选择，可以自行搜索相关教程，这里不再展开，下面提供一个 `transform-runtime` 的参考配置方案。\n\n- 首先安装 runtime 相关依赖\n\n```\nnpm i @babel/plugin-transform-runtime -D\nnpm i @babel/runtime -S\n```\n\n修改 `.babelrc`\n\n```json\n{\n  //...\n  \"plugins\": [\"@babel/plugin-transform-runtime\"]\n}\n```\n\n### 打包前清理源目录文件 clean-webpack-plugin\n\n每次打包，都会生成项目的静态资源，随着某些文件的增删，我们的 dist 目录下可能产生一些不再使用的静态资源，webpack 并不会自动判断哪些是需要的资源，为了不让这些旧文件也部署到生产环境上占用空间，所以在 webpack 打包前最好能清理 dist 目录。\n\n```\nnpm install clean-webpack-plugin -D\n```\n\n修改 `webpack.config.js` 文件\n\n```js\nconst CleanWebpackPlugin = require('clean-webpack-plugin')\nmodule.exports = {\n  plugins: [new CleanWebpackPlugin(['dist'])]\n}\n```\n\n### 提取公用代码\n\n假如你 `a.js` 和 `b.js` 都 import 了 `c.js` 文件，这段代码就冗杂了。为什么要提取公共代码，简单来说，就是减少代码冗余，提高加载速度。\n\n```js\nmodule.exports = {\n  //...\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        commons: {\n          // 抽离自己写的公共代码\n          chunks: 'initial',\n          name: 'common', // 打包后的文件名，任意命名\n          minChunks: 2, //最小引用2次\n          minSize: 0 // 只要超出0字节就生成一个新包\n        },\n        styles: {\n          name: 'styles', // 抽离公用样式\n          test: /\\.css$/,\n          chunks: 'all',\n          minChunks: 2,\n          enforce: true\n        },\n        vendor: {\n          // 抽离第三方插件\n          test: /node_modules/, // 指定是node_modules下的第三方包\n          chunks: 'initial',\n          name: 'vendor', // 打包后的文件名，任意命名\n          // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包\n          priority: 10\n        }\n      }\n    }\n  }\n}\n```\n\n### hash\n\nhash 是干嘛用的？\n我们每次打包出来的结果可能都是同一个文件，那我上线的时候是不是要替换掉上线的 js，那我怎么知道哪是最新的呢，我们一般会清一下缓存。而 hash 就是为了解决这个问题而存在的\n\n我们此时在改一些 webpack.config.js 的配置\n\n```js\nmodule.exports = {\n  //...\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[hash:8].js'\n  },\n  //...\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: '[name].[hash:8].css',\n      chunkFilename: '[id].[hash:8].css'\n    })\n  ]\n}\n```\n\n### 减少 resolve 的解析，配置别名\n\n如果我们可以精简 `resolve` 配置，让 `webpack` 在查询模块路径时尽可能快速地定位到需要的模块，不做额外的查询工作，那么 `webpack` 的构建速度也会快一些\n\n```js\nmodule.exports = {\n  resolve: {\n    /**\n     * alias: 别名的配置\n     *\n     * extensions: 自动解析确定的扩展,\n     *    比如 import 'xxx/theme.css' 可以在extensions 中添加 '.css'， 引入方式则为 import 'xxx/theme'\n     *    @default ['.wasm', '.mjs', '.js', '.json']\n     *\n     * modules 告诉 webpack 解析模块时应该搜索的目录\n     *   如果你想要添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索\n     *   这样配置在某种程度上可以简化模块的查找，提升构建速度 @default node_modules 优先\n     */\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n      tool$: path.resolve(__dirname, 'src/utils/tool.js') // 给定对象的键后的末尾添加 $，以表示精准匹配\n    },\n    extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx'],\n    modules: [path.resolve(__dirname, 'src'), 'node_modules']\n  }\n}\n```\n\n### webpack-dev-serve\n\n上面讲到了都是如何打包文件，但是开发中我们需要一个本地服务，这时我们可以使用 `webpack-dev-server` 在本地开启一个简单的静态服务来进行开发。\n\n`webpack-dev-server` 是 webpack 官方提供的一个工具，可以基于当前的 webpack 构建配置快速启动一个静态服务。当 `mode` 为 `development` 时，会具备 `hot reload` 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果。...\n\n```\nnpm install webpack-dev-server -D\n```\n\npackage.json 中 scripts 中添加\n\n```\n\"start\": \"webpack-dev-server --mode development\"\n```\n\n默认开启一个本地服务的窗口 http://localhost:8080/ 便于开发\n\n#### 配置开发服务器\n\n我们可以对 `webpack-dev-server` 做针对性的配置\n\n```js\nmodule.exports = {\n  // 配置开发服务器\n  devServer: {\n    port: 1234,\n    open: true, // 自动打开浏览器\n    compress: true // 服务器压缩\n    //... proxy、hot\n  }\n}\n```\n\n- contentBase: 服务器访问的根目录（可用于访问静态资源）\n- port: 端口\n- open: 自动打开浏览器\n\n### 模块热替换(hot module replacement)\n\n模块热替换(`HMR - Hot Module Replacement`)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：\n\n- 保留在完全重新加载页面时丢失的应用程序状态。\n- 只更新变更内容，以节省宝贵的开发时间。\n- 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。\n\n上面我们 `npm start` 后修改一次文件，页面就会刷新一次。这样就存在很大问题了，比如我们使用 `redux`, `vuex` 等插件，页面一刷新那么存放在 `redux`, `vuex` 中的东西就会丢失，非常不利于我们的开发。\n\nHMR 配合 webpack-dev-server ，首先我们配置下 webpack.config.js\n\n```js\nconst webpack = require('webpack')\n\nmodule.exports = {\n  devServer: {\n    //...\n    hot: true\n  },\n  plugins: [\n    new webpack.HotModuleReplacementPlugin()\n    //...\n  ]\n}\n```\n\n配置后还不行，因为 webpack 还不知道你要更新哪里, 修改 `src/index.js` 文件, 添加\n\n```js\nif (module.hot) {\n  module.hot.accept()\n}\n```\n\n重启服务，`npm start` 之后，修改引入 `index.js` 文件后，页面就不会重新刷新了，这便实现了 HMR\n\n但是但是有个问题是，你修改 css/less 等样式文件并未发生改变， what ?\n\nHMR 修改样式表 需要借助于 `style-loader`， 而我们之前用的是 `MiniCssExtractPlugin.loader`， 这也好办，修改其中一个 rules 就可以了，我们可以试试改\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        use: [\n          // MiniCssExtractPlugin.loader,\n          'style-loader',\n          'css-loader',\n          {\n            loader: 'postcss-loader',\n            options: {\n              plugins: [require('autoprefixer')] // 添加css中的浏览器前缀\n            }\n          },\n          'less-loader'\n        ]\n      }\n    ]\n  }\n}\n```\n\n这样我们修改 less 文件就会发现 HMR 已经实现了。\n\n其实，我们可以发现，dev 下配置的 loader 为 `style-loader` , 而生产环境下则是需要 `MiniCssExtractPlugin.loader`\n\n这就涉及到了不同环境之间的配置。可以通过 `process.env.NODE_ENV` 获取当前是开发环境或者是生产环境，然后配置不同的 loader，这里就不做展开了。下一篇文章打算在做一个 `react-cli` 或者 `vue-cli` 的配置，将开发环境的配置与生产环境的配置分开为不同的文件。\n\n### 结语\n\n前面讲到的知识都是 webpack 的一些基础的知识，更多的资料可以查询[webpack 中文官网](https://webpack.js.org/)，官网讲的比较详细，我这里也是讲最常的配置，也是一篇入门系列的文章，文中涉及的知识点还有很多地方还需要完善，譬如 优化 webpack 的构建速度， 减小打包的体积等等。\n\n学习 `webpack 4.0` 还需要多实践，多瞎搞，笔者也是刚刚学习 webpack 的配置，不对之处请各位指出。\n\n下一篇文章打算从零配置一个脚手架，以加深自己对 webpack 的理解。\n\n本文产生的代码：[webpack-dev](https://github.com/gershonv/my-code-store/tree/master/webpack/webpack-dev)\n\n### 参考\n\n- [webpack4.x 入门一篇足矣](https://juejin.im/post/5b2b9a00e51d45587b48075e#heading-0)\n- [Webpack4 不深不浅的实践教程](https://segmentfault.com/a/1190000014466696?utm_source=index-hottest/*&%5E%25$#articleHeader0)\n- [webpack 之 babel 配置和 HMR](https://juejin.im/post/5b3834e051882574ce2f3dd9)\n- [使用 webpack 4 和 Babel 7 配置 Vue.js 工程模板](https://segmentfault.com/a/1190000015247255)\n- [webpack 4 ：从 0 配置到项目搭建](https://juejin.im/post/5b3daf2ee51d451962727fbe)\n- [webpack 详解](https://juejin.im/post/5aa3d2056fb9a028c36868aa)\n- [手写一个 webpack4.0 配置](https://juejin.im/post/5b4609f5e51d4519596b66a7)\n- [Webpack 4 教程：从零配置到生产发布（2018）](https://juejin.im/entry/5b552985f265da0f697036b2)\n- [Webpack 揭秘——走向高阶前端的必经之路](https://juejin.im/post/5badd0c5e51d450e4437f07a)\n- [珠峰架构师培训公开课 webpack4.0 进阶](https://www.bilibili.com/video/av25439651?from=search&seid=14183256954711376795)\n- [webpack 官网](https://webpack.js.org/)\n"
  },
  {
    id: 2,
    title: 'Node.js 实战',
    content:
      "## 前言\n这是本人的学习的记录，因为最近在准备面试，很多情况下会被提问到：请简述 `mvvm` ?\n一般情况下我可能这么答：`mvvm` 是视图和逻辑的一个分离，是`model view view-model` 的缩写，通过虚拟dom的方式实现双向数据绑定（我随便答得）\n\n那么问题来了，你知道 `mvvm` 是怎么实现的？\n回答: `mvvm` 主要通过 `Object` 的 `defineProperty` 属性，重写 `data` 的 `set` 和`get` 函数来实现。 ok，回答得60分，那么你知道具体实现过程么？想想看，就算他没问到而你答了出来是不是更好？前提下，一定要手撸一下简单的`mvvm`才会对它有印象~\n\n话不多说，接下来是参考自张仁阳老师的教学视频而作，采用的是[ES6](http://es6.ruanyifeng.com/#docs/class)语法，其中也包含了我个人的理解，如果能帮助到您，我将十分高兴。如有错误之处，请各位大佬指正出来，不胜感激~~~\n\n在实现之前，请先了解基本的`mvvm`的编译过程以及使用\n- 编译的流程图\n![](https://user-gold-cdn.xitu.io/2018/7/18/164ac9a02d21c8cb?w=700&h=374&f=jpeg&s=31670)\n\n- 整体分析\n![](https://user-gold-cdn.xitu.io/2018/7/18/164ac90097e68912?w=639&h=388&f=png&s=49631)\n\n可以发现`new MVVM()`后的编译过程主体分为两个部分：\n\n1. 一部分是模板的编译 `Compile`\n    - 编译元素和文本，最终渲染到页面中\n    - 其中标签中有模板指令的标签才执行编译 例如`<div>我很帅</div>` 不执行编译\n2. 一部分是数据劫持 `Observer`\n    - `Dep` 发布订阅，将所有需要通知变化的`data`添加到一个数组中\n    - `Watcher` 如果数据发生改变，在`Object`的`defineProperty`的`set`函数中调用`Watcher`的`update`方法\n\n#### 明确本文需要实现的目标\n1. **实现模板编译的过程 完成`Vue`实例中的属性可以正确绑定在标签中，并且渲染在页面中**\n   -  工作：指令的解析，正则替换双大括号\n   -  将节点的内容`node.textContent`或者`input`的`value`编译出来\n2. **完成数据的双向绑定**\n   - 工作：通过`observe`类劫持数据变化\n   - 添加发布与订阅：`Object.defineProperty` 在`get`钩子中`addSub`,`set`钩子中通知变化`dep.notify()`\n   - `dep.notify()`调用的是`Watcher`的`update`方法，也就是说需要在`input`变化时调用更新\n   \n<!--more-->\n\n##  分解 Vue 实例\n如何入手？首先从怎么使用`Vue`开始。让我们一步步解析`Vue`的使用：\n\n```js\nlet vm = new Vue({\n    el: '#app'\n    data: {\n        message: 'hello world'\n    }\n})\n```\n上面代码可以看出使用`Vue`,我们是先`new` 一个`Vue` 实例，传一个对象参数，包含 `el` 和 `data`。\n\nok，以上得到了信息，接下来让我们实现**目标1**：将`Vue`实例的`data`编译到页面中\n\n## 实现 Complie 编译模板的过程\n先看看页面的使用：`index.html`\n```html\n<div id=\"app\">\n    <input type=\"text\" v-model=\"jsonText.text\">\n    <div>{{message}}</div>\n    {{jsonText.text}}\n</div>\n<script src=\"./watcher.js\"></script>\n<script src=\"./observer.js\"></script>\n<script src=\"./compile.js\"></script>\n<script src=\"./vue.js\"></script>\n<script>\n    let vm = new Vue({\n        el: '#app',\n        data: {\n            message: 'gershonv',\n            jsonText:{\n                text: 'hello Vue'\n            }\n        }\n    })\n</script>\n```\n\n> 第一步当然是添加`Vue`类作为一个入口文件。\n\n### vue 类-入口文件的添加\n新建一个`vue.js`文件，其代码如下\n构造函数中定义`$el`和`$data`，因为后面的编译要使用到\n\n```js\nclass Vue {\n    constructor(options) {\n        this.$el = options.el; // 挂载\n        this.$data = options.data;\n\n        // 如果有要编译的模板就开始编译\n        if (this.$el) {\n            // 用数据和元素进行编译\n            new Compile(this.$el, this)\n        }\n    }\n}\n```\n- 这里暂时未添加数据劫持`obeserve`，实现目标1暂时未用到，后续再添加\n- 编译需要 `el` 和相关数据，上面代码执行后会有编译，所以我们新建一个执行编译的类的文件\n\n> 这里在入口文件`vue.js`中`new`了一个`Compile`实例，所以接下来新建`compile.js`\n\n### Compile 类-模板编译的添加\n`Compile` 需要做什么？\n我们知道页面中操作`dom`会消耗性能，所以可以把`dom`移入内存处理：\n1. 先把真实的 `dom` 移入到内存中 （在内存中操作`dom`速度比较快）\n    - 怎么放在内存中？可以利用文档碎片 `fragment`\n2. 编译 `compile(fragment){}`\n    - 提取想要的元素节点和文本节点 `v-model` 双大括号，然后进行相关操作。\n3. 把编译好的`fragment`塞回页面里去\n```js\nclass Compile {\n    constructor(el, vm) {\n        this.el = this.isElementNode(el) ? el : document.querySelector(el);\n        this.vm = vm;\n        if (this.el) {// 如果这个元素能获取到 我们才开始编译\n            // 1.先把这些真实的DOM移入到内存中 fragment[文档碎片]\n            let fragment = this.node2fragment(this.el)\n            // 2.编译 => 提取想要的元素节点 v-model 和文本节点 {{}}\n            this.compile(fragment)\n            // 3.编译好的fragment在塞回页面里去\n            this.el.appendChild(fragment)\n        }\n    }\n\n    /* 专门写一些辅助的方法 */\n    isElementNode(node) { // 判断是否为元素及节点，用于递归遍历节点条件\n        return node.nodeType === 1;\n    }\n\n    /* 核心方法 */\n    node2fragment(el) { // 将el的内容全部放入内存中\n        // 文档碎片\n        let fragment = document.createDocumentFragment();\n        let firstChild;\n\n        while (firstChild = el.firstChild) { // 移动DOM到文档碎片中\n            fragment.appendChild(firstChild)\n        }\n        return fragment;\n    }\n    \n    compile(fragment) {\n    }\n}\n```\n> 编译的过程就是把我们的数据渲染好，表现在视图中\n\n#### 编译过程 compile(fragment)\n- 第一步：获取元素的节点，提取其中的指令或者模板双大括号\n    - 首先需要遍历节点，用到了**递归方法**，因为有节点嵌套的关系，`isElementNode` 代表是节点元素，也是递归的终止的判断条件。\n- 第二步：分类编译指令的方法`compileElement` 和 编译文本双大括号的方法\n    - `compileElement` 对`v-model`、`v-text`等指令的解析\n    - `compileText` 编译文本节点 双大括号\n```js\nclass Compile{\n    // ...\n    compile(fragment) {\n        // 遍历节点 可能节点套着又一层节点 所以需要递归\n        let childNodes = fragment.childNodes\n        Array.from(childNodes).forEach(node => {\n            if (this.isElementNode(node)) {\n                // 是元素节点 继续递归\n                // 这里需要编译元素\n                this.compileElement(node);\n                this.compile(node)\n            } else {\n                // 文本节点\n                // 这里需要编译文本\n                this.compileText(node)\n            }\n        })\n    }\n}\n```\n\n##### compileElement && compileText\n1. 取出元素的属性 `node.attributes` 先判断是否包含指令\n2. 判断指令类型(`v-html v-text v-model...`) 调用不一样的数据更新方法\n    - 这里提取了编译的工具对象 `CompileUtil`\n    - 调用方法: `CompileUtil[type](node, this.vm, expr)`\n        - `CompileUtil.类型(节点，实例，v-XX 绑定的属性值)`  \n\n```js\nclass Compile{\n    // ...\n    \n    // 判断是否是指令 ==> compileElement 中递归标签属性中使用\n    isDirective(name) {\n        return name.includes('v-')\n    }\n    \n    compileElement(node) {\n        // v-model 编译\n        let attrs = node.attributes; // 取出当前节点的属性\n        Array.from(attrs).forEach(attr => {\n            let attrName = attr.name;\n            // 判断属性名是否包含 v-\n            if (this.isDirective(attrName)) {\n                // 取到对应的值，放到节点中\n                let expr = attr.value;\n                // v-model v-html v-text...\n                let [, type] = attrName.split('-')\n                CompileUtil[type](node, this.vm, expr);\n            }\n        })\n    }\n    compileText(node) {\n        // 编译 {{}}\n        let expr = node.textContent; //取文本中的内容\n        let reg = /\\{\\{([^}]+)\\}\\}/g;\n        if (reg.test(expr)) {\n            CompileUtil['text'](node, this.vm, expr)\n        }\n    }\n    \n    // compile(fragment){...}\n}\nCompileUtil = {\n    getVal(vm, expr) { // 获取实例上对应的数据\n        expr = expr.split('.'); // 处理 jsonText.text 的情况\n        return expr.reduce((prev, next) => { \n            return prev[next] // 譬如 vm.$data.jsonText.text、vm.$data.message\n        }, vm.$data)\n    },\n    getTextVal(vm, expr) { // 获取文本编译后的结果\n        return expr.replace(/\\{\\{([^}]+)\\}\\}/g, (...arguments) => {\n            return this.getVal(vm, arguments[1])\n        })\n    },\n    text(node, vm, expr) { // 文本处理 参数 [节点, vm 实例, 指令的属性值]\n        let updateFn = this.updater['textUpdater'];\n        let value = this.getTextVal(vm, expr)\n        updateFn && updateFn(node, value)\n    },\n    model(node, vm, expr) { // 输入框处理\n        let updateFn = this.updater['modelUpdater'];\n        updateFn && updateFn(node, this.getVal(vm, expr))\n    },\n    updater: {\n        // 文本更新\n        textUpdater(node, value) {\n            node.textContent = value\n        },\n        // 输入框更新\n        modelUpdater(node, value) {\n            node.value = value;\n        }\n    }\n}\n```\n\n到现在为止 就完成了数据的绑定，也就是说`new Vue` 实例中的 `data` 已经可以正确显示在页面中了，现在要解决的就是**如何实现双向绑定**\n\n结合开篇的`vue`编译过程的图可以知道我们还少一个`observe` 数据劫持，`Dep`通知变化,添加`Watcher`监听变化, 以及最终重写`data`属性\n\n\n## 实现双向绑定\n\n### Observer 类-观察者的添加\n1. 在`vue.js` 中劫持数据\n```js\nclass Vue{\n    //...\n    if(this.$el){\n       new Observer(this.$data); // 数据劫持\n       new Compile(this.$el, this); // 用数据和元素进行编译\n    }  \n}\n```\n2. 新建 `observer.js` 文件\n\n代码步骤：\n- 构造器中添加直接进行 `observe`\n  - 判断`data` 是否存在, 是否是个对象（new Vue 时可能不写`data`属性）\n  - 将数据一一劫持，获取`data`中的`key`和`value`\n```js\nclass Observer {\n    constructor(data) {\n        this.observe(data)\n    }\n\n    observe(data) {\n        // 要对这个数据将原有的属性改成 set 和 get 的形式\n        if (!data || typeof data !== 'object') {\n            return\n        }\n        // 将数据一一劫持\n        Object.keys(data).forEach(key => {\n            // 劫持\n            this.defineReactive(data, key, data[key])\n            this.observe(data[key]) //递归深度劫持\n        })\n    }\n\n    defineReactive(obj, key, value) {\n        let that = this\n        Object.defineProperty(obj, key, {\n            enumerable: true,\n            configurable: true,\n            get() { // 取值时调用的方法\n                return value\n            },\n            set(newValue) { // 当给data属性中设置的时候，更改属性的值\n                if (newValue !== value) {\n                    // 这里的this不是实例\n                    that.observe(newValue) // 如果是对象继续劫持\n                    value = newValue\n                }\n            }\n        })\n    }\n}\n```\n> 虽然有了`observer`，但是并未关联,以及通知变化。下面就添加`Watcher`类\n\n### Watcher 类的添加\n新建`watcher.js`文件\n- 观察者的目的就是给需要变化的那个元素增加一个观察者，当数据变化后执行对应的方法\n- \n\n先回忆下`watch`的用法：`this.$watch(vm, 'a', function(){...})`\n我们在添加发布订阅者时需要传入参数有: **vm实例，v-XX绑定的属性, cb回调函数**\n（`getVal` 方法拷贝了之前 `CompileUtil` 的方法，其实可以提取出来的...）\n\n```js\nclass Watcher {\n    // 观察者的目的就是给需要变化的那个元素增加一个观察者，当数据变化后执行对应的方法\n    // this.$watch(vm, 'a', function(){...})\n    constructor(vm, expr, cb) {\n        this.vm = vm;\n        this.expr = expr;\n        this.cb = cb;\n\n        // 先获取下老的值\n        this.value = this.get();\n    }\n\n    getVal(vm, expr) { // 获取实例上对应的数据\n        expr = expr.split('.');\n        return expr.reduce((prev, next) => { //vm.$data.a\n            return prev[next]\n        }, vm.$data)\n    }\n\n    get() {\n        let value = this.getVal(this.vm, this.expr);\n        return value\n    }\n\n    // 对外暴露的方法\n    update(){\n        let newValue = this.getVal(this.vm, this.expr);\n        let oldValue = this.value\n\n        if(newValue !== oldValue){\n            this.cb(newValue); // 对应 watch 的callback\n        }\n    }\n}\n\n```\n`Watcher` 定义了但是还没有调用，模板编译的时候，需要调观察的时候观察一下\n`Compile`\n```js\nclass Compile{\n    //...\n}\nCompileUtil = {\n    //...\n    text(node, vm, expr) { // 文本处理 参数 [节点, vm 实例, 指令的属性值]\n        let updateFn = this.updater['textUpdater'];\n        let value = this.getTextVal(vm, expr)\n        updateFn && updateFn(node, value)\n\n        expr.replace(/\\{\\{([^}]+)\\}\\}/g, (...arguments) => {\n            new Watcher(vm, arguments[1], () => {\n                // 如果数据变化了，文本节点需要重新获取依赖的属性更新文本中的内容\n                updateFn && updateFn(node, this.getTextVal(vm, expr))\n            })\n        })\n    },\n    //...\n    model(node, vm, expr) { // 输入框处理\n        let updateFn = this.updater['modelUpdater'];\n        // 这里应该加一个监控，数据变化了，应该调用watch 的callback\n        new Watcher(vm, expr, (newValue) => {\n            // 当值变化后会调用cb 将newValue传递过来（）\n            updateFn && updateFn(node, this.getVal(vm, expr))\n        });\n\n        node.addEventListener('input', e => {\n            let newValue = e.target.value;\n            this.setVal(vm, expr, newValue)\n        })\n        updateFn && updateFn(node, this.getVal(vm, expr))\n    },\n    \n    //...\n}\n```\n实现了监听后发现变化并没有通知到所有指令绑定的模板或是双大括号，所以我们需要`Dep` 监控、实例的发布订阅属性的一个类，我们可以添加到`observer.js`中\n\n### Dep 类的添加\n注意 第一次编译的时候不会调用`Watcher`，`dep.target`不存在,`new Watcher`的时候`target`才有值 \n有点绕，看下面代码：\n```js\nclass Watcher {\n    constructor(vm, expr, cb) {\n        //...\n        this.value = this.get()\n    }\n    get(){\n        Dep.target = this;\n        let value = this.getVal(this.vm, this.expr);\n        Dep.target = null;\n        return value\n    }\n    //...\n}\n\n// compile.js\nCompileUtil = {\n    model(node, vm, expr) { // 输入框处理\n        //...\n        new Watcher(vm, expr, (newValue) => {\n            // 当值变化后会调用cb 将newValue传递过来（）\n            updateFn && updateFn(node, this.getVal(vm, expr))\n        });\n    }\n}\n```\n\n```js\nclass Observer{\n    //...\n    defineReactive(obj, key, value){\n        let that = this;\n        let dep = new Dep(); // 每个变化的数据 都会对应一个数组，这个数组存放所有更新的操作\n        Object.defineProperty(obj, key, {\n            //...\n            get(){\n                Dep.target && dep.addSub(Dep.target)\n                //...\n            }\n             set(newValue){\n                 if (newValue !== value) {\n                    // 这里的this不是实例\n                    that.observe(newValue) // 如果是对象继续劫持\n                    value = newValue;\n                    dep.notify(); //通知所有人更新了\n                }\n             }\n        })\n    }\n}\nclass Dep {\n    constructor() {\n        // 订阅的数组\n        this.subs = []\n    }\n\n    addSub(watcher) {\n        this.subs.push(watcher)\n    }\n\n    notify() {\n        this.subs.forEach(watcher => watcher.update())\n    }\n}\n```\n\n以上代码 就完成了**发布订阅者**模式,简单的实现。。也就是说双向绑定的目标2已经完成了\n\n---\n## 结语\n板门弄斧了，本人无意哗众取宠，这只是一篇我的学习记录的文章。想分享出来，这样才有进步。\n如果这篇文章帮助到您，我将十分高兴。有问题可以提`issue`，有错误之处也希望大家能提出来，非常感激。\n\n具体源码我放在了我的github了，有需要的自取。\n[源码链接](https://github.com/gershonv/my-code-store)"
  }
];

const PreviewList = () => {
  return (
    <div className="entry-list-wrap">
      <div className="markdown-body">
        {articles.map((a) => {
          // const preview = truncateMarkdown(a.content, 150);
          const preview = a.content;
          return (
            <div key={a.id} style={{ borderBottom: '1px solid #eee', padding: '16px 0' }}>
              <h2>
                <Link to={`/article/${a.id}`}>{a.title}</Link>
              </h2>
              <ReactMarkdown
                remarkPlugins={[remarkGfm]}
                rehypePlugins={[rehypeSlug, rehypeAutolinkHeadings]}
              >
                {preview}
              </ReactMarkdown>
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default memo(PreviewList);
